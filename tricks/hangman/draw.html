<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="theme-color" content="#000000">
    <title>Hangman Drawing</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiBmaWxsPSIjRkZFQjNCIi8+CjxwYXRoIGQ9Ik05NiA0OEM4MC41MzYgNDggNjggNjAuNTM2IDY4IDc2VjExNkM2OCAxMzEuNDY0IDgwLjUzNiAxNDQgOTYgMTQ0UzEyNCAxMzEuNDY0IDEyNCAxMTZWNzZDMTI0IDYwLjUzNiAxMTEuNDY0IDQ4IDk2IDQ4WiIgZmlsbD0iIzMzMzMzMyIvPgo8Y2lyY2xlIGN4PSI4NCIgY3k9IjY4IiByPSI0IiBmaWxsPSIjRkZFQjNCIi8+CjxjaXJjbGUgY3g9IjEwOCIgY3k9IjY4IiByPSI0IiBmaWxsPSIjRkZFQjNCIi8+CjxwYXRoIGQ9Ik04NCA4OEMxMDQgODggMTA0IDk2IDg0IDk2IiBzdHJva2U9IiNGRkVCM0IiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+CjwvZz4KPC9zdmc+">
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #000; min-height: 100vh; display: flex; flex-direction: column;
            touch-action: manipulation; overflow: hidden;
        }
        .button-area { background: #FFEB3B; padding: 4px; text-align: center; position: sticky; top: 0; z-index: 100; border-bottom: 2px solid #FFC107; }
        .button-grid { display: flex; justify-content: center; gap: 3px; flex-wrap: nowrap; max-width: 100%; }
        .btn { background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); border: none; border-radius: 4px; padding: 4px 6px; color: white; font-size: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: .2px; box-shadow: 0 1px 3px rgba(76,175,80,.3); min-height: 24px; min-width: 40px; touch-action: manipulation; flex: 1; }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 3px 10px rgba(76,175,80,.4); }
        .btn:active { transform: translateY(0); box-shadow: 0 1px 4px rgba(76,175,80,.3); }
        .btn.secondary { background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); box-shadow: 0 2px 6px rgba(33,150,243,.3); }
        .btn.info { background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%); box-shadow: 0 2px 6px rgba(255,152,0,.3); }
        .btn.active { background: linear-gradient(135deg, #FF5722 0%, #D32F2F 100%); box-shadow: 0 2px 6px rgba(255,87,34,.5); transform: translateY(-1px); }
        .main-content { flex: 1; display: flex; flex-direction: column; justify-content: flex-start; align-items: stretch; padding: 0; position: relative; background: #000; }
        .canvas { border: none; border-radius: 0; background: #fff; width: 100vw; height: calc(100vh - 34px); margin: 0; cursor: crosshair; transition: height .2s; }
        body.debug-active .canvas { height: calc(100vh - 34px); }
        .anagram-overlay { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,.8); color: #6ee7b7; padding: 8px 12px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; z-index: 150; border: 1px solid #6ee7b7; display: none; }
        .anagram-zone-indicator { position: absolute; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.6); color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 10px; z-index: 140; display: none; }
        .anagram-zone-top { top: 10px; } .anagram-zone-bottom { bottom: 140px; }
        .status-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); background: rgba(0,0,0,.8); color: #fff; padding: 20px 30px; border-radius: 12px; font-size: 18px; font-weight: 500; z-index: 1000; opacity: 0; transition: opacity .3s; pointer-events: none; }
        .status-indicator.show { opacity: 1; }
        .debug-panel { display: none; position: fixed; top: 40px; left: 10px; width: 300px; height: 300px; background: rgba(0,0,0,.9); color: #fff; padding: 12px; overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px; z-index: 150; border: 2px solid rgba(255,255,255,.3); border-radius: 8px; line-height: 1.3; }
        .debug-panel.show { display: block; }
        .debug-status { margin-bottom: 8px; padding: 4px; border-left: 3px solid #4CAF50; font-size: 10px; }
        .debug-button { background: #4CAF50; color: #fff; border: none; border-radius: 4px; padding: 4px 8px; font-size: 9px; cursor: pointer; margin: 2px; min-width: 60px; }
        .debug-button.secondary { background: #2196F3; } .debug-button.secondary:hover { background: #1976D2; }
        .debug-content { max-height: 200px; overflow-y: auto; margin-top: 8px; padding: 4px; background: rgba(255,255,255,.1); border-radius: 4px; font-size: 9px; }
        .debug-toggle { position: fixed; bottom: 20px; right: 20px; background: rgba(0,0,0,.7); color: #fff; border: none; border-radius: 50%; width: 60px; height: 60px; font-size: 20px; cursor: pointer; z-index: 300; display: none; }
        .debug-toggle.show { display: block; }
        .result-area { margin: 0; padding: 0; background: transparent; border: none; border-radius: 0; font-family: 'Courier New', monospace; white-space: nowrap; overflow-x: auto; overflow-y: hidden; max-width: 100%; word-break: keep-all; font-size: 11px; line-height: 1.2; }
        .error-message { color: #d32f2f; font-weight: bold; }
        .success-message { color: #388e3c; font-weight: bold; }
        .fallback-input { margin-top: 15px; padding: 15px; width: 100%; border: 2px solid #ddd; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 14px; resize: vertical; min-height: 120px; }
        .fallback-input:focus { outline: none; border-color: #4CAF50; box-shadow: 0 0 0 3px rgba(76,175,80,.1); }
        .process-btn { background: #4CAF50; color: #fff; border: none; border-radius: 8px; padding: 12px 24px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 12px; transition: background .2s; }
        .process-btn:hover { background: #45a049; }
        .invisible-input { position: fixed; left: -9999px; opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <div class="button-area">
        <div class="button-grid">
            <button class="btn" id="draw">Draw</button>
            <button class="btn secondary" id="erase">Erase</button>
            <button class="btn info" id="debug">Debug</button>
            <button class="btn secondary" id="clear">Clear</button>
            <button class="btn info" id="undo">Undo</button>
        </div>
    </div>
    
    <div class="main-content">
        <canvas class="canvas" id="drawingCanvas"></canvas>
        <div class="anagram-zone-indicator anagram-zone-top" id="anagramZoneTop">Draw here for NO</div>
        <div class="anagram-zone-indicator anagram-zone-bottom" id="anagramZoneBottom">Draw here for YES</div>
        <div class="anagram-overlay" id="anagramOverlay">
            <div id="anagramQuestion">Loading...</div>
            <div id="anagramResult" style="display: none;"></div>
        </div>
    </div>
    
    <div class="status-indicator" id="statusIndicator"></div>
    
    <div class="debug-panel" id="debugPanel">
        <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #555; padding-bottom: 4px;">DEBUG WINDOW</div>
        <div class="debug-status" id="debugModeStatus">Mode: LOADING</div>
        <div class="debug-status" id="debugWordsStatus">Words: LOADING</div>
        <div class="debug-status" id="debugPAStatus">PA Generation: LOADING</div>
        <div class="debug-status" id="debugPAComplete">PA Complete: NO</div>
        <div class="debug-status" id="debugLastPAInput">Last PA Input: -</div>
        <div style="margin-top: 8px;">
            <button class="debug-button" onclick="showWords()">View Words</button>
            <button class="debug-button secondary" onclick="showPA()">View PA</button>
        </div>
        <div class="debug-content" id="debugContent" style="display: none;"></div>
    </div>
    
    <button class="debug-toggle" id="debugToggle" title="Toggle Debug Panel">ðŸ”§</button>
    <textarea class="invisible-input" id="invisibleClipboardField" readonly></textarea>

    <script>
        // ---- SIMPLE LIST LOADER (uses #list=word1,word2,...; falls back to localStorage) ----
        function loadWordsFromList(){
          const m = location.hash.match(/(?:^|#|&)list=([^&]+)/);
          if(!m){
            try { return JSON.parse(localStorage.getItem('PA_WORDS')||'[]'); }
            catch { return []; }
          }
          try{
            const decoded = decodeURIComponent(m[1]);
            const words = decoded.split(',').map(w=>w.trim()).filter(Boolean);
            localStorage.setItem('PA_WORDS', JSON.stringify(words));
            history.replaceState(null,'', location.pathname + location.search);
            return words;
          }catch{ return []; }
        }
        window.WORDS = loadWordsFromList();

        // Global anagram/debug state
        window.anagramState = {
            wordsLoaded: Array.isArray(window.WORDS) && window.WORDS.length > 0,
            serviceInitialized: false,
            currentSession: null,
            isNavigating: false
        };
        window.debugState = {
            currentMode: 'STANDBY',
            wordsLoaded: Array.isArray(window.WORDS) && window.WORDS.length > 0,
            wordsCount: window.WORDS ? window.WORDS.length : 0,
            paGenerating: false,
            paComplete: false,
            lastPAInput: null
        };

        const updateDebugStatus = () => {
            if (!isDebugMode()) return;
            document.getElementById('debugModeStatus').textContent = `Mode: ${window.debugState.currentMode}`;
            document.getElementById('debugWordsStatus').textContent = `Words: ${window.debugState.wordsLoaded ? 'YES (' + window.debugState.wordsCount + ')' : 'NO'}`;
            document.getElementById('debugPAStatus').textContent = `PA Generation: ${window.debugState.paGenerating ? 'YES' : 'NO'}`;
            document.getElementById('debugPAComplete').textContent = `PA Complete: ${window.debugState.paComplete ? 'YES' : 'NO'}`;
            document.getElementById('debugLastPAInput').textContent = `Last PA Input: ${window.debugState.lastPAInput || '-'}`;
        };

        const showWords = () => {
            const debugContent = document.getElementById('debugContent');
            if (window.WORDS && window.WORDS.length > 0) {
                debugContent.innerHTML = `<strong>Loaded Words (${window.WORDS.length}):</strong><br>` + 
                    window.WORDS.map((word, i) => `${i+1}. ${word}`).join('<br>');
                debugContent.style.display = 'block';
            } else {
                debugContent.innerHTML = '<strong>No words loaded</strong>';
                debugContent.style.display = 'block';
            }
        };

        const showPA = () => {
            const debugContent = document.getElementById('debugContent');
            if (window.anagramState.serviceInitialized && window.anagramState.currentSession) {
                try {
                    const status = AnagramService.getStatus();
                    let paInfo = '<strong>PA Tree Structure:</strong><br>';
                    paInfo += `Path: ${status.path || 'None'}<br>`;
                    paInfo += `Current Question: ${status.currentQuestion || 'None'}<br>`;
                    paInfo += `Remaining Words: ${status.remainingWords || 0}<br>`;
                    paInfo += `Complete: ${status.completed ? 'YES' : 'NO'}<br>`;
                    if (status.result) paInfo += `Result: ${Array.isArray(status.result) ? status.result.join(', ') : status.result}`;
                    debugContent.innerHTML = paInfo;
                } catch (e) {
                    debugContent.innerHTML = '<strong>PA Tree:</strong><br>Error retrieving PA structure: ' + e.message;
                }
                debugContent.style.display = 'block';
            } else {
                debugContent.innerHTML = '<strong>PA Tree:</strong><br>PA service not initialized';
                debugContent.style.display = 'block';
            }
        };

        (function() {
            let anagramStarted = false;
            const MAX_RETRY_TIME = 5000, RETRY_INTERVAL = 250;

            function startProgressiveAnagram(words) {
                try {
                    if (typeof AnagramService === 'undefined') {
                        const script = document.createElement('script');
                        script.src = '../../assets/js/anagram.js';
                        script.onload = () => {
                            const script2 = document.createElement('script');
                            script2.src = '../../assets/js/anagram-service.js';
                            script2.onload = () => { initializeAnagramService(words); };
                            document.head.appendChild(script2);
                        };
                        document.head.appendChild(script);
                        return;
                    }
                    initializeAnagramService(words);
                } catch (error) { console.log('[DEBUG] Progressive anagram initialization error:', error); }
            }
            window.startProgressiveAnagram = startProgressiveAnagram;

            function initializeAnagramService(words) {
                try {
                    window.debugState.paGenerating = true; updateDebugStatus();
                    const result = AnagramService.initialize(words, { entropy: true });
                    if (result.success) {
                        console.log('[DEBUG] Progressive anagram started with', result.wordCount, 'words');
                        window.anagramState.serviceInitialized = true;
                        window.anagramState.currentSession = AnagramService;
                        window.debugState.paGenerating = false;
                        window.debugState.paComplete = true; updateDebugStatus();
                        if (isDebugMode()) { debugLog('Progressive anagram initialized', { wordCount: result.wordCount, firstQuestion: result.firstQuestion }); startAnagramNavigation(); }
                    } else {
                        console.log('[DEBUG] Progressive anagram initialization failed:', result.error);
                        window.anagramState.serviceInitialized = false;
                        window.debugState.paGenerating = false;
                        window.debugState.paComplete = false; updateDebugStatus();
                        if (isDebugMode()) { debugLog('Progressive anagram initialization failed', { error: result.error }); }
                    }
                } catch (error) {
                    console.log('[DEBUG] AnagramService initialization error:', error);
                    window.anagramState.serviceInitialized = false;
                    window.debugState.paGenerating = false;
                    window.debugState.paComplete = false; updateDebugStatus();
                    if (isDebugMode()) { debugLog('AnagramService error', { error: error.message }); }
                }
            }

            function tryStartAnagram() {
                if (anagramStarted) return true;
                if (Array.isArray(window.WORDS) && window.WORDS.length > 0 && typeof window.startProgressiveAnagram === 'function') {
                    anagramStarted = true; window.startProgressiveAnagram(window.WORDS); return true;
                }
                return false;
            }

            function retryWithTimeout(startTime) {
                if (Date.now() - startTime > MAX_RETRY_TIME) { console.log('[DEBUG] Progressive anagram initialization timeout'); return; }
                if (tryStartAnagram()) return;
                setTimeout(() => retryWithTimeout(startTime), RETRY_INTERVAL);
            }

            function handleFirstCanvasInteraction() {
                if (anagramStarted) return;
                console.log('[DEBUG] First canvas interaction detected');
                if (tryStartAnagram()) { removeCanvasListeners(); }
                else { console.log('[DEBUG] Starting progressive anagram retry loop'); retryWithTimeout(Date.now()); removeCanvasListeners(); }
            }

            function removeCanvasListeners() {
                const canvas = document.getElementById('drawingCanvas') || document.querySelector('canvas');
                if (canvas) {
                    canvas.removeEventListener('pointerdown', handleFirstCanvasInteraction);
                    canvas.removeEventListener('mousedown', handleFirstCanvasInteraction);
                    canvas.removeEventListener('touchstart', handleFirstCanvasInteraction);
                }
            }

            function setupCanvasListeners() {
                const canvas = document.getElementById('drawingCanvas') || document.querySelector('canvas');
                if (canvas) {
                    canvas.addEventListener('pointerdown', handleFirstCanvasInteraction, { passive: true, once: false });
                    canvas.addEventListener('mousedown', handleFirstCanvasInteraction, { passive: true, once: false });
                    canvas.addEventListener('touchstart', handleFirstCanvasInteraction, { passive: true, once: false });
                    console.log('[DEBUG] Canvas listeners set up for progressive anagram lazy init');
                } else { console.log('[DEBUG] Canvas not found for progressive anagram setup'); }
            }

            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', setupCanvasListeners);
            else setupCanvasListeners();
        })();

        function startAnagramNavigation() {
            if (!isDebugMode() || !window.anagramState.serviceInitialized) return;
            window.anagramState.isNavigating = true;
            window.debugState.currentMode = 'PA_NAVIGATION';
            updateDebugStatus(); updateAnagramDisplay(); showAnagramZones();
        }
        function updateAnagramDisplay() {
            const overlay = document.getElementById('anagramOverlay');
            const questionEl = document.getElementById('anagramQuestion');
            const resultEl = document.getElementById('anagramResult');
            if (!window.anagramState.serviceInitialized || !isDebugMode()) { overlay.style.display = 'none'; return; }
            const currentQuestion = AnagramService.getCurrentQuestion();
            if (currentQuestion) {
                questionEl.textContent = currentQuestion.question; questionEl.style.display = 'block';
                resultEl.style.display = 'none'; overlay.style.display = 'block';
            } else if (AnagramService.isCompleted) {
                const status = AnagramService.getStatus();
                if (status.result && status.result.length > 0) {
                    questionEl.style.display = 'none';
                    resultEl.innerHTML = `<strong>Result:</strong> ${status.result.join(', ')}`;
                    resultEl.style.display = 'block'; overlay.style.display = 'block'; hideAnagramZones();
                }
            }
        }
        function showAnagramZones() {
            if (!isDebugMode() || !window.anagramState.isNavigating) return;
            document.getElementById('anagramZoneTop').style.display = 'block';
            document.getElementById('anagramZoneBottom').style.display = 'block';
        }
        function hideAnagramZones() {
            document.getElementById('anagramZoneTop').style.display = 'none';
            document.getElementById('anagramZoneBottom').style.display = 'none';
        }
        function handleAnagramNavigation(y, canvasHeight) {
            if (!isDebugMode() || !window.anagramState.isNavigating || !window.anagramState.serviceInitialized) return;
            const topThird = canvasHeight / 3, bottomThird = canvasHeight * 2 / 3;
            let answer = null, inputText = null;
            if (y <= topThird) { answer = false; inputText = 'NO'; }
            else if (y >= bottomThird) { answer = true; inputText = 'YES'; }
            else { return; }
            window.debugState.lastPAInput = inputText; updateDebugStatus();
            const result = AnagramService.answerQuestion(answer);
            if (result.success) { updateAnagramDisplay(); if (result.completed) { debugLog('Anagram navigation complete', { result: result.result }); window.debugState.currentMode = 'PA_COMPLETE'; updateDebugStatus(); } }
        }

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => { console.log('SW registered:', reg); })
                    .catch(err => { console.log('SW registration failed:', err); });
            });
        }

        const isDebugMode = () => {
            return new URLSearchParams(window.location.search).has('debug') || 
                   localStorage.getItem('debugMode') === 'true';
        };
        const debugLog = (message, data = null) => { if (isDebugMode()) console.log('[DEBUG]', message, data || ''); };
        const showStatus = (message, isError = false, duration = 2000) => {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = message;
            indicator.style.background = isError ? 'rgba(211,47,47,.9)' : 'rgba(76,175,80,.9)';
            indicator.classList.add('show');
            if (window.statusTimeout) clearTimeout(window.statusTimeout);
            window.statusTimeout = setTimeout(() => { indicator.classList.remove('show'); }, duration);
        };

        document.addEventListener('DOMContentLoaded', () => {
            const drawButton = document.getElementById('draw');
            const eraseButton = document.getElementById('erase');
            const debugButton = document.getElementById('debug');
            const clearButton = document.getElementById('clear');
            const undoButton = document.getElementById('undo');
            const debugPanel = document.getElementById('debugPanel');
            const debugToggle = document.getElementById('debugToggle');

            debugLog('Application initialized', { debugMode: isDebugMode() });

            if (isDebugMode()) {
                if (window.WORDS.length > 0) debugLog('Words loaded from URL/localStorage', { count: window.WORDS.length, words: window.WORDS });
                else debugLog('No words loaded - empty word list');
                updateDebugStatus();
            }

            const { canvas, ctx } = setupCanvas();
            window.addEventListener('resize', () => {
                const rect = canvas.getBoundingClientRect();
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                canvas.width = rect.width; canvas.height = rect.height; ctx.putImageData(imageData, 0, 0);
                if (isDebugMode()) drawDebugGrid(ctx, canvas.width, canvas.height);
            });

            if (isDebugMode()) { debugPanel.classList.add('show'); debugToggle.classList.add('show'); document.body.classList.add('debug-active'); }
            debugToggle.addEventListener('click', () => { debugPanel.classList.toggle('show'); document.body.classList.toggle('debug-active'); });

            drawButton.addEventListener('click', () => {
                isDrawing = true; isErasing = false; window.debugState.currentMode = 'DRAWING'; updateDebugStatus();
                drawButton.classList.add('active'); eraseButton.classList.remove('active'); canvas.style.cursor = 'crosshair';
                showStatus('Draw mode enabled', false, 1000);
            });
            eraseButton.addEventListener('click', () => {
                isErasing = true; isDrawing = false; window.debugState.currentMode = 'ERASING'; updateDebugStatus();
                eraseButton.classList.add('active'); drawButton.classList.remove('active'); canvas.style.cursor = 'grab';
                showStatus('Erase mode enabled', false, 1000);
            });
            debugButton.addEventListener('click', () => {
                const current = isDebugMode(); localStorage.setItem('debugMode', (!current).toString());
                if (!current) { debugPanel.classList.add('show'); debugToggle.classList.add('show'); document.body.classList.add('debug-active'); showStatus('Debug mode enabled - reload to see grid', false, 2000); }
                else { debugPanel.classList.remove('show'); debugToggle.classList.remove('show'); document.body.classList.remove('debug-active'); showStatus('Debug mode disabled - reload to hide grid', false, 2000); }
            });
            clearButton.addEventListener('click', () => {
                clearCanvas(canvas, ctx); isDrawing = false; isErasing = false; window.debugState.currentMode = 'STANDBY'; updateDebugStatus();
                drawButton.classList.remove('active'); eraseButton.classList.remove('active'); canvas.style.cursor = 'default'; showStatus('Canvas cleared', false, 1000);
            });
            undoButton.addEventListener('click', () => { undoLastAction(canvas, ctx); showStatus('Last action undone', false, 1000); });

            canvas.addEventListener('mousedown', e => { e.preventDefault(); startDrawing(e, canvas, ctx); });
            canvas.addEventListener('mousemove', e => { e.preventDefault(); draw(e, canvas, ctx); });
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', e => { e.preventDefault(); startDrawing(e, canvas, ctx); });
            canvas.addEventListener('touchmove', e => { e.preventDefault(); draw(e, canvas, ctx); });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);
        });

        let isDrawing = false, isErasing = false;
        let drawingHistory = [], currentPath = [];

        const setupCanvas = () => {
            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.lineWidth = 3; ctx.strokeStyle = '#333';
            if (isDebugMode()) drawDebugGrid(ctx, canvas.width, canvas.height);
            return { canvas, ctx };
        };
        const drawDebugGrid = (ctx, w, h) => {
            ctx.save(); ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.setLineDash([5,5]);
            const th = h/3; ctx.beginPath(); ctx.moveTo(0, th); ctx.lineTo(w, th); ctx.moveTo(0, th*2); ctx.lineTo(w, th*2); ctx.stroke(); ctx.restore();
        };
        const startDrawing = (e, canvas, ctx) => {
            if (!isDrawing && !isErasing) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            if (isDebugMode() && window.anagramState.isNavigating) handleAnagramNavigation(y, canvas.height);
            ctx.beginPath(); ctx.moveTo(x, y);
            currentPath = [{x, y, mode: isErasing ? 'erase' : 'draw'}];
        };
        const draw = (e, canvas, ctx) => {
            if (!isDrawing && !isErasing) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            if (isErasing) { ctx.globalCompositeOperation = 'destination-out'; ctx.lineWidth = 10; }
            else { ctx.globalCompositeOperation = 'source-over'; ctx.lineWidth = 3; }
            ctx.lineTo(x, y); ctx.stroke();
            currentPath.push({x, y, mode: isErasing ? 'erase' : 'draw'});
        };
        const stopDrawing = () => {
            if (currentPath.length > 0) { drawingHistory.push([...currentPath]); currentPath = []; }
        };
        const clearCanvas = (canvas, ctx) => {
            ctx.clearRect(0, 0, canvas.width, canvas.height); drawingHistory = [];
            if (isDebugMode()) drawDebugGrid(ctx, canvas.width, canvas.height);
        };
        const undoLastAction = (canvas, ctx) => {
            if (drawingHistory.length === 0) return;
            drawingHistory.pop(); ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (isDebugMode()) drawDebugGrid(ctx, canvas.width, canvas.height);
            drawingHistory.forEach(path => {
                if (!path.length) return;
                ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
                path.forEach((p, i) => {
                    if (i === 0) return;
                    if (p.mode === 'erase') { ctx.globalCompositeOperation = 'destination-out'; ctx.lineWidth = 10; }
                    else { ctx.globalCompositeOperation = 'source-over'; ctx.lineWidth = 3; }
                    ctx.lineTo(p.x, p.y); ctx.stroke();
                });
            });
        };
    </script>
</body>
</html>